<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Xenomai: Thread services</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Xenomai"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Xenomai
   &#160;<span id="projectnumber">3.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__cobalt__core__thread.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Thread services<div class="ingroups"><a class="el" href="group__cobalt.html">Cobalt</a> &raquo; <a class="el" href="group__cobalt__core.html">Cobalt kernel</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Thread services:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__cobalt__core__thread.png" border="0" alt="" usemap="#group____cobalt____core____thread"/>
<map name="group____cobalt____core____thread" id="group____cobalt____core____thread">
<area shape="rect" id="node1" href="group__cobalt__core__thread__states.html" title="Bits reporting permanent or transient states of threads. " alt="" coords="317,5,443,32"/><area shape="rect" id="node2" href="group__cobalt__core__thread__info.html" title="Bits reporting events notified to threads. " alt="" coords="315,57,445,98"/><area shape="rect" id="node4" href="group__cobalt__core.html" title="The Cobalt core is a co&#45;kernel which supplements the Linux kernel for delivering real&#45;time services w..." alt="" coords="5,35,104,61"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__cobalt__core__thread__states"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread__states.html">Thread state flags</a></td></tr>
<tr class="memdesc:group__cobalt__core__thread__states"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bits reporting permanent or transient states of threads. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__cobalt__core__thread__info"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread__info.html">Thread information flags</a></td></tr>
<tr class="memdesc:group__cobalt__core__thread__info"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bits reporting events notified to threads. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga277e327d3802107ed35dc768cb01509c"><td class="memItemLeft" align="right" valign="top">static struct xnthread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current</a> (void)</td></tr>
<tr class="memdesc:ga277e327d3802107ed35dc768cb01509c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current Cobalt core TCB.  <a href="#ga277e327d3802107ed35dc768cb01509c">More...</a><br /></td></tr>
<tr class="separator:ga277e327d3802107ed35dc768cb01509c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd94ae095598618f568dec7360d3a10c"><td class="memItemLeft" align="right" valign="top">static struct xnthread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#gabd94ae095598618f568dec7360d3a10c">xnthread_from_task</a> (struct task_struct *p)</td></tr>
<tr class="memdesc:gabd94ae095598618f568dec7360d3a10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the Cobalt core TCB attached to a Linux task.  <a href="#gabd94ae095598618f568dec7360d3a10c">More...</a><br /></td></tr>
<tr class="separator:gabd94ae095598618f568dec7360d3a10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5af31ef43f67d3124886dc5fc528753"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#gab5af31ef43f67d3124886dc5fc528753">xnthread_test_cancel</a> (void)</td></tr>
<tr class="memdesc:gab5af31ef43f67d3124886dc5fc528753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduce a thread cancellation point.  <a href="#gab5af31ef43f67d3124886dc5fc528753">More...</a><br /></td></tr>
<tr class="separator:gab5af31ef43f67d3124886dc5fc528753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75a7e56d8c8ea2c7462db4d7a35f228e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#ga75a7e56d8c8ea2c7462db4d7a35f228e">xnthread_init</a> (struct xnthread *thread, const struct xnthread_init_attr *attr, struct xnsched_class *sched_class, const union xnsched_policy_param *sched_param)</td></tr>
<tr class="memdesc:ga75a7e56d8c8ea2c7462db4d7a35f228e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new thread.  <a href="#ga75a7e56d8c8ea2c7462db4d7a35f228e">More...</a><br /></td></tr>
<tr class="separator:ga75a7e56d8c8ea2c7462db4d7a35f228e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabedfb90d24b08db04e49b168d290e032"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#gabedfb90d24b08db04e49b168d290e032">xnthread_start</a> (struct xnthread *thread, const struct xnthread_start_attr *attr)</td></tr>
<tr class="memdesc:gabedfb90d24b08db04e49b168d290e032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a newly created thread.  <a href="#gabedfb90d24b08db04e49b168d290e032">More...</a><br /></td></tr>
<tr class="separator:gabedfb90d24b08db04e49b168d290e032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c57e5332785644f1dc0c95ad2ee5097"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#ga3c57e5332785644f1dc0c95ad2ee5097">xnthread_set_mode</a> (int clrmask, int setmask)</td></tr>
<tr class="memdesc:ga3c57e5332785644f1dc0c95ad2ee5097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change control mode of the current thread.  <a href="#ga3c57e5332785644f1dc0c95ad2ee5097">More...</a><br /></td></tr>
<tr class="separator:ga3c57e5332785644f1dc0c95ad2ee5097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab49f7e0bb3c3ede3d52a47ee18794bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc">xnthread_suspend</a> (struct xnthread *thread, int mask, xnticks_t timeout, xntmode_t timeout_mode, struct xnsynch *wchan)</td></tr>
<tr class="memdesc:gaab49f7e0bb3c3ede3d52a47ee18794bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a thread.  <a href="#gaab49f7e0bb3c3ede3d52a47ee18794bc">More...</a><br /></td></tr>
<tr class="separator:gaab49f7e0bb3c3ede3d52a47ee18794bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9321320f5f883f20a4cb411ce585f115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115">xnthread_resume</a> (struct xnthread *thread, int mask)</td></tr>
<tr class="memdesc:ga9321320f5f883f20a4cb411ce585f115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume a thread.  <a href="#ga9321320f5f883f20a4cb411ce585f115">More...</a><br /></td></tr>
<tr class="separator:ga9321320f5f883f20a4cb411ce585f115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fe02cbf0d0cebc0ca9d9522bc58e65a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#ga8fe02cbf0d0cebc0ca9d9522bc58e65a">xnthread_unblock</a> (struct xnthread *thread)</td></tr>
<tr class="memdesc:ga8fe02cbf0d0cebc0ca9d9522bc58e65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock a thread.  <a href="#ga8fe02cbf0d0cebc0ca9d9522bc58e65a">More...</a><br /></td></tr>
<tr class="separator:ga8fe02cbf0d0cebc0ca9d9522bc58e65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0b5bb03ce22a7ef882729d24bfe2804"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#gad0b5bb03ce22a7ef882729d24bfe2804">xnthread_set_periodic</a> (struct xnthread *thread, xnticks_t idate, xntmode_t timeout_mode, xnticks_t period)</td></tr>
<tr class="memdesc:gad0b5bb03ce22a7ef882729d24bfe2804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a thread periodic.  <a href="#gad0b5bb03ce22a7ef882729d24bfe2804">More...</a><br /></td></tr>
<tr class="separator:gad0b5bb03ce22a7ef882729d24bfe2804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga002449afde30d3b736ac558895ff5ab2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#ga002449afde30d3b736ac558895ff5ab2">xnthread_wait_period</a> (unsigned long *overruns_r)</td></tr>
<tr class="memdesc:ga002449afde30d3b736ac558895ff5ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the next periodic release point.  <a href="#ga002449afde30d3b736ac558895ff5ab2">More...</a><br /></td></tr>
<tr class="separator:ga002449afde30d3b736ac558895ff5ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92e19fc9deb691b7851e0f9fe21a825c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#ga92e19fc9deb691b7851e0f9fe21a825c">xnthread_set_slice</a> (struct xnthread *thread, xnticks_t quantum)</td></tr>
<tr class="memdesc:ga92e19fc9deb691b7851e0f9fe21a825c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set thread time-slicing information.  <a href="#ga92e19fc9deb691b7851e0f9fe21a825c">More...</a><br /></td></tr>
<tr class="separator:ga92e19fc9deb691b7851e0f9fe21a825c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcf46b2b38ac68322f354adc408c2732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#gabcf46b2b38ac68322f354adc408c2732">xnthread_cancel</a> (struct xnthread *thread)</td></tr>
<tr class="memdesc:gabcf46b2b38ac68322f354adc408c2732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel a thread.  <a href="#gabcf46b2b38ac68322f354adc408c2732">More...</a><br /></td></tr>
<tr class="separator:gabcf46b2b38ac68322f354adc408c2732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac61d70ab94c430e8d96b455221d2fea3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#gac61d70ab94c430e8d96b455221d2fea3">xnthread_join</a> (struct xnthread *thread, bool uninterruptible)</td></tr>
<tr class="memdesc:gac61d70ab94c430e8d96b455221d2fea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join with a terminated thread.  <a href="#gac61d70ab94c430e8d96b455221d2fea3">More...</a><br /></td></tr>
<tr class="separator:gac61d70ab94c430e8d96b455221d2fea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4cb747799fc0ac47e2a209c835f524d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#gae4cb747799fc0ac47e2a209c835f524d">xnthread_harden</a> (void)</td></tr>
<tr class="memdesc:gae4cb747799fc0ac47e2a209c835f524d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate a Linux task to the Xenomai domain.  <a href="#gae4cb747799fc0ac47e2a209c835f524d">More...</a><br /></td></tr>
<tr class="separator:gae4cb747799fc0ac47e2a209c835f524d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0dad9aaac79565e12343b3b27a37c83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#gaa0dad9aaac79565e12343b3b27a37c83">xnthread_relax</a> (int notify, int reason)</td></tr>
<tr class="memdesc:gaa0dad9aaac79565e12343b3b27a37c83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch a shadow thread back to the Linux domain.  <a href="#gaa0dad9aaac79565e12343b3b27a37c83">More...</a><br /></td></tr>
<tr class="separator:gaa0dad9aaac79565e12343b3b27a37c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff2b4720f1a104a4f26f38da3370ba4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#ga2ff2b4720f1a104a4f26f38da3370ba4">xnthread_map</a> (struct xnthread *thread, struct completion *done)</td></tr>
<tr class="memdesc:ga2ff2b4720f1a104a4f26f38da3370ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shadow thread context over a kernel task.  <a href="#ga2ff2b4720f1a104a4f26f38da3370ba4">More...</a><br /></td></tr>
<tr class="separator:ga2ff2b4720f1a104a4f26f38da3370ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae78ee27f53ae4d947b271b98748c78e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#gae78ee27f53ae4d947b271b98748c78e9">xnthread_migrate</a> (int cpu)</td></tr>
<tr class="memdesc:gae78ee27f53ae4d947b271b98748c78e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Migrate the current thread.  <a href="#gae78ee27f53ae4d947b271b98748c78e9">More...</a><br /></td></tr>
<tr class="separator:gae78ee27f53ae4d947b271b98748c78e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb78d40c8065b8569fafe7e24960742e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cobalt__core__thread.html#gafb78d40c8065b8569fafe7e24960742e">xnthread_set_schedparam</a> (struct xnthread *thread, struct xnsched_class *sched_class, const union xnsched_policy_param *sched_param)</td></tr>
<tr class="memdesc:gafb78d40c8065b8569fafe7e24960742e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the base scheduling parameters of a thread.  <a href="#gafb78d40c8065b8569fafe7e24960742e">More...</a><br /></td></tr>
<tr class="separator:gafb78d40c8065b8569fafe7e24960742e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabcf46b2b38ac68322f354adc408c2732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnthread_cancel </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel a thread. </p>
<p>Request cancellation of a thread. This service forces <em>thread</em> to exit from any blocking call, then to switch to secondary mode. <em>thread</em> will terminate as soon as it reaches a cancellation point. Cancellation points are defined for the following situations:</p>
<ul>
<li><em>thread</em> self-cancels by a call to <a class="el" href="group__cobalt__core__thread.html#gabcf46b2b38ac68322f354adc408c2732" title="Cancel a thread. ">xnthread_cancel()</a>.</li>
<li><em>thread</em> invokes a Linux syscall (user-space shadow only).</li>
<li><em>thread</em> receives a Linux signal (user-space shadow only).</li>
<li><em>thread</em> unblocks from a Xenomai syscall (user-space shadow only).</li>
<li><em>thread</em> attempts to block on a Xenomai syscall (user-space shadow only).</li>
<li><em>thread</em> explicitly calls <a class="el" href="group__cobalt__core__thread.html#gab5af31ef43f67d3124886dc5fc528753" title="Introduce a thread cancellation point. ">xnthread_test_cancel()</a>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the thread to terminate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted, might-switch</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>In addition to the common actions taken upon cancellation, a thread which belongs to the SCHED_WEAK class is sent a regular SIGTERM signal. </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__info.html#gac0c8d3c13b2ea3ceb9c8b474b9e52f01">XNCANCELD</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga5fa9672a03ebd4beaf7ab3caa5699fa6">XNDORMANT</a>, <a class="el" href="group__cobalt__core__thread__info.html#gab6ee242aa7e0f98235c5099cd345984c">XNKICKED</a>, <a class="el" href="group__cobalt__core__sched.html#gab51b1711cd73d890278e3998c817cc3a">xnsched_run()</a>, <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>, <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115">xnthread_resume()</a>, <a class="el" href="group__cobalt__core__thread.html#gab5af31ef43f67d3124886dc5fc528753">xnthread_test_cancel()</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga4d188db22a4cc3f521934cdcc6ba7d06">XNUSER</a>, and <a class="el" href="group__cobalt__core__thread__states.html#gae7835ab0a2123b72a6818c6ea3923ba0">XNWEAK</a>.</p>

<p>Referenced by <a class="el" href="group__rtdm__task.html#ga44b0701b6c28fa8035711f800fdcd371">rtdm_task_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga277e327d3802107ed35dc768cb01509c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct xnthread * xnthread_current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the current Cobalt core TCB. </p>
<p>Returns the address of the current Cobalt core thread descriptor, or NULL if running over a regular Linux task. This call is not affected by the current runtime mode of the core thread.</p>
<dl class="section note"><dt>Note</dt><dd>The returned value may differ from xnsched_current_thread() called from the same context, since the latter returns the root thread descriptor for the current CPU if the caller is running in secondary mode.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

<p>Referenced by <a class="el" href="group__rtdm__sync__event.html#gaf76f858a3951ca2e20d3b1e00afa17e0">rtdm_event_timedwait()</a>, <a class="el" href="group__rtdm__sync__mutex.html#ga0789968300701ba2a940f5fe8b1fd4d8">rtdm_mutex_timedlock()</a>, <a class="el" href="group__rtdm__sync__sem.html#ga8aadb120a93df5dfd717c5bac6d4c1a9">rtdm_sem_timeddown()</a>, <a class="el" href="group__cobalt__core__synch.html#ga43fa3ecdc81f6ae157f840175c7ea091">xnsynch_acquire()</a>, <a class="el" href="group__cobalt__core__synch.html#ga51cec970cb57608abe882c98bee72347">xnsynch_sleep_on()</a>, <a class="el" href="group__cobalt__core__synch.html#gad5cad7eeaa18834c9ba8843511a67628">xnsynch_try_acquire()</a>, <a class="el" href="group__cobalt__core__thread.html#gabcf46b2b38ac68322f354adc408c2732">xnthread_cancel()</a>, <a class="el" href="group__cobalt__core__thread.html#gae4cb747799fc0ac47e2a209c835f524d">xnthread_harden()</a>, <a class="el" href="group__cobalt__core__thread.html#gac61d70ab94c430e8d96b455221d2fea3">xnthread_join()</a>, <a class="el" href="group__cobalt__core__thread.html#ga2ff2b4720f1a104a4f26f38da3370ba4">xnthread_map()</a>, <a class="el" href="group__cobalt__core__thread.html#gae78ee27f53ae4d947b271b98748c78e9">xnthread_migrate()</a>, <a class="el" href="group__cobalt__core__thread.html#gaa0dad9aaac79565e12343b3b27a37c83">xnthread_relax()</a>, <a class="el" href="group__cobalt__core__thread.html#gad0b5bb03ce22a7ef882729d24bfe2804">xnthread_set_periodic()</a>, <a class="el" href="group__cobalt__core__thread.html#gab5af31ef43f67d3124886dc5fc528753">xnthread_test_cancel()</a>, and <a class="el" href="group__cobalt__core__thread.html#ga002449afde30d3b736ac558895ff5ab2">xnthread_wait_period()</a>.</p>

</div>
</div>
<a class="anchor" id="gabd94ae095598618f568dec7360d3a10c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct xnthread * xnthread_from_task </td>
          <td>(</td>
          <td class="paramtype">struct task_struct *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the Cobalt core TCB attached to a Linux task. </p>
<p>Returns the address of the Cobalt core thread descriptor attached to the Linux task <em>p</em>, or NULL if <em>p</em> is a regular Linux task. This call is not affected by the current runtime mode of the core thread.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae4cb747799fc0ac47e2a209c835f524d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_harden </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate a Linux task to the Xenomai domain. </p>
<p>This service causes the transition of "current" from the Linux domain to Xenomai. The shadow will resume in the Xenomai domain as returning from schedule().</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only, might-switch</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__states.html#gadf5508cd88c2678ae01dfaf5570c661c">XNRELAX</a>, <a class="el" href="group__cobalt__core__thread__states.html#gaa44db9c525cd4e87eaced36ea47a6cf3">XNSSTEP</a>, <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>, <a class="el" href="group__cobalt__core__thread.html#gaa0dad9aaac79565e12343b3b27a37c83">xnthread_relax()</a>, and <a class="el" href="group__cobalt__core__thread.html#gab5af31ef43f67d3124886dc5fc528753">xnthread_test_cancel()</a>.</p>

<p>Referenced by <a class="el" href="group__cobalt__core__thread.html#ga2ff2b4720f1a104a4f26f38da3370ba4">xnthread_map()</a>.</p>

</div>
</div>
<a class="anchor" id="ga75a7e56d8c8ea2c7462db4d7a35f228e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_init </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct xnthread_init_attr *&#160;</td>
          <td class="paramname"><em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnsched_class *&#160;</td>
          <td class="paramname"><em>sched_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const union xnsched_policy_param *&#160;</td>
          <td class="paramname"><em>sched_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new thread. </p>
<p>Initializes a new thread. The thread is left dormant until it is actually started by <a class="el" href="group__cobalt__core__thread.html#gabedfb90d24b08db04e49b168d290e032" title="Start a newly created thread. ">xnthread_start()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The address of a thread descriptor the nucleus will use to store the thread-specific data. This descriptor must always be valid while the thread is active therefore it must be allocated in permanent memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Some architectures may require the descriptor to be properly aligned in memory; this is an additional reason for descriptors not to be laid in the program stack where alignement constraints might not always be satisfied.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attr</td><td>A pointer to an attribute block describing the initial properties of the new thread. Members of this structure are defined as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>name: An ASCII string standing for the symbolic name of the thread. This name is copied to a safe place into the thread descriptor. This name might be used in various situations by the nucleus for issuing human-readable diagnostic messages, so it is usually a good idea to provide a sensible value here. NULL is fine though and means "anonymous".</li>
<li>flags: A set of creation flags affecting the operation. The following flags can be part of this bitmask, each of them affecting the nucleus behaviour regarding the created thread:<ul>
<li>XNSUSP creates the thread in a suspended state. In such a case, the thread shall be explicitly resumed using the <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115" title="Resume a thread. ">xnthread_resume()</a> service for its execution to actually begin, additionally to issuing <a class="el" href="group__cobalt__core__thread.html#gabedfb90d24b08db04e49b168d290e032" title="Start a newly created thread. ">xnthread_start()</a> for it. This flag can also be specified when invoking <a class="el" href="group__cobalt__core__thread.html#gabedfb90d24b08db04e49b168d290e032" title="Start a newly created thread. ">xnthread_start()</a> as a starting mode.</li>
</ul>
</li>
<li>XNUSER shall be set if <em>thread</em> will be mapped over an existing user-space task. Otherwise, a new kernel host task is created, then paired with the new Xenomai thread.</li>
<li>XNFPU (enable FPU) tells the nucleus that the new thread may use the floating-point unit. XNFPU is implicitly assumed for user-space threads even if not set in <em>flags</em>.</li>
<li>affinity: The processor affinity of this thread. Passing CPU_MASK_ALL means "any cpu" from the allowed core affinity mask (cobalt_cpu_affinity). Passing an empty set is invalid.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sched_class</td><td>The initial scheduling class the new thread should be assigned to.</td></tr>
    <tr><td class="paramname">sched_param</td><td>The initial scheduling parameters to set for the new thread; <em>sched_param</em> must be valid within the context of <em>sched_class</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise, the following error code indicates the cause of the failure:</dd></dl>
<ul>
<li>-EINVAL is returned if <em>attr-&gt;flags</em> has invalid bits set, or <em>attr-&gt;affinity</em> is invalid (e.g. empty).</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__states.html#ga6b2ca9336a15f94f3a2e0665982ed081">XNFPU</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga6b605ad2bb16ae2386821be8ce8d341b">XNSUSP</a>, and <a class="el" href="group__cobalt__core__thread__states.html#ga4d188db22a4cc3f521934cdcc6ba7d06">XNUSER</a>.</p>

<p>Referenced by <a class="el" href="group__rtdm__task.html#ga44b0701b6c28fa8035711f800fdcd371">rtdm_task_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gac61d70ab94c430e8d96b455221d2fea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_join </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>uninterruptible</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join with a terminated thread. </p>
<p>This service waits for <em>thread</em> to terminate after a call to <a class="el" href="group__cobalt__core__thread.html#gabcf46b2b38ac68322f354adc408c2732" title="Cancel a thread. ">xnthread_cancel()</a>. If that thread has already terminated or is dormant at the time of the call, then <a class="el" href="group__cobalt__core__thread.html#gac61d70ab94c430e8d96b455221d2fea3" title="Join with a terminated thread. ">xnthread_join()</a> returns immediately.</p>
<p><a class="el" href="group__cobalt__core__thread.html#gac61d70ab94c430e8d96b455221d2fea3" title="Join with a terminated thread. ">xnthread_join()</a> adapts to the calling context (primary or secondary).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the thread to join with.</td></tr>
    <tr><td class="paramname">uninterruptible</td><td>Boolean telling whether the service should wait for completion uninterruptible if called from secondary mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise, the following error codes indicate the cause of the failure:</dd></dl>
<ul>
<li>-EDEADLK is returned if the current thread attempts to join itself.</li>
<li>-EINTR is returned if the current thread was unblocked while waiting for <em>thread</em> to terminate.</li>
<li>-EBUSY indicates that another thread is already waiting for <em>thread</em> to terminate.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted, might-switch</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__info.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga5fa9672a03ebd4beaf7ab3caa5699fa6">XNDORMANT</a>, <a class="el" href="group__cobalt__core__thread__states.html#gaaae7bc444a180ad0672bf710801d0275">XNJOINED</a>, <a class="el" href="group__cobalt__core__thread__info.html#gab07d9dea73645dbba353dc2452c15b40">XNRMID</a>, <a class="el" href="group__cobalt__core__synch.html#ga51cec970cb57608abe882c98bee72347">xnsynch_sleep_on()</a>, and <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>.</p>

<p>Referenced by <a class="el" href="group__rtdm__task.html#ga3a3e4c00605861403c0ea4ec87b31a7b">rtdm_task_join()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2ff2b4720f1a104a4f26f38da3370ba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_map </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct completion *&#160;</td>
          <td class="paramname"><em>done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a shadow thread context over a kernel task. </p>
<p>This call maps a nucleus thread to the "current" Linux task running in kernel space. The priority and scheduling class of the underlying Linux task are not affected; it is assumed that the caller did set them appropriately before issuing the shadow mapping request.</p>
<p>This call immediately moves the calling kernel thread to the Xenomai domain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the new shadow thread to be mapped to "current". This descriptor must have been previously initialized by a call to <a class="el" href="group__cobalt__core__thread.html#ga75a7e56d8c8ea2c7462db4d7a35f228e" title="Initialize a new thread. ">xnthread_init()</a>.</td></tr>
    <tr><td class="paramname">done</td><td>A completion object to be signaled when <em>thread</em> is fully mapped over the current Linux context, waiting for <a class="el" href="group__cobalt__core__thread.html#gabedfb90d24b08db04e49b168d290e032" title="Start a newly created thread. ">xnthread_start()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise:</dd></dl>
<ul>
<li>-ERESTARTSYS is returned if the current Linux task has received a signal, thus preventing the final migration to the Xenomai domain (i.e. in order to process the signal in the Linux domain). This error should not be considered as fatal.</li>
<li>-EPERM is returned if the shadow thread has been killed before the current task had a chance to return to the caller. In such a case, the real-time mapping operation has failed globally, and no Xenomai resource remains attached to it.</li>
<li>-EINVAL is returned if the thread control block bears the XNUSER bit.</li>
<li>-EBUSY is returned if either the current Linux task or the associated shadow thread is already involved in a shadow mapping.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">secondary-only, might-switch</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__states.html#ga5fa9672a03ebd4beaf7ab3caa5699fa6">XNDORMANT</a>, <a class="el" href="group__cobalt__core__thread__states.html#gaabc63b4b55fdf5db7469d4532ed35fd2">XNMAPPED</a>, <a class="el" href="group__cobalt__core__thread__states.html#gadf5508cd88c2678ae01dfaf5570c661c">XNRELAX</a>, <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>, <a class="el" href="group__cobalt__core__thread.html#gae4cb747799fc0ac47e2a209c835f524d">xnthread_harden()</a>, <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115">xnthread_resume()</a>, <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc">xnthread_suspend()</a>, <a class="el" href="group__cobalt__core__thread.html#gab5af31ef43f67d3124886dc5fc528753">xnthread_test_cancel()</a>, and <a class="el" href="group__cobalt__core__thread__states.html#ga4d188db22a4cc3f521934cdcc6ba7d06">XNUSER</a>.</p>

</div>
</div>
<a class="anchor" id="gae78ee27f53ae4d947b271b98748c78e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_migrate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cpu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Migrate the current thread. </p>
<p>This call makes the current thread migrate to another (real-time) CPU if its affinity allows it. This call is available from primary mode only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cpu</td><td>The destination CPU.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the thread could migrate ; </td></tr>
    <tr><td class="paramname">-EPERM</td><td>if the calling context is invalid, or the scheduler is locked. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if the current thread affinity forbids this migration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__timer.html#gabcea9e49706bb130bb63ada53ec4bd87">__xntimer_migrate()</a>, <a class="el" href="group__cobalt__core__thread__info.html#ga2cb10fa1e4e888e3e23798b42deb1608">XNMOVED</a>, <a class="el" href="group__cobalt__core__sched.html#gab51b1711cd73d890278e3998c817cc3a">xnsched_run()</a>, and <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa0dad9aaac79565e12343b3b27a37c83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnthread_relax </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>notify</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reason</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch a shadow thread back to the Linux domain. </p>
<p>This service yields the control of the running shadow back to Linux. This is obtained by suspending the shadow and scheduling a wake up call for the mated user task inside the Linux domain. The Linux task will resume on return from <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc" title="Suspend a thread. ">xnthread_suspend()</a> on behalf of the root thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">notify</td><td>A boolean flag indicating whether threads monitored from secondary mode switches should be sent a SIGDEBUG signal. For instance, some internal operations like task exit should not trigger such signal.</td></tr>
    <tr><td class="paramname">reason</td><td>The reason to report along with the SIGDEBUG signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>"current" is valid here since the shadow runs with the properties of the Linux task. </dd></dl>

<p>References <a class="el" href="group__cobalt__core__lock.html#ga8b52de3d55575c5b15e8d494f40f8a6a">splmax</a>, <a class="el" href="group__cobalt__core__lock.html#gae28d03201ec825ca3bd3e7cea6a0b77d">splnone</a>, <a class="el" href="group__cobalt__core__thread__info.html#ga2cb10fa1e4e888e3e23798b42deb1608">XNMOVED</a>, <a class="el" href="group__cobalt__core__thread__states.html#gadf5508cd88c2678ae01dfaf5570c661c">XNRELAX</a>, <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>, <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc">xnthread_suspend()</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga4d188db22a4cc3f521934cdcc6ba7d06">XNUSER</a>, and <a class="el" href="group__cobalt__core__thread__states.html#ga44a2c7ec314961aacb1934636cb33482">XNWARN</a>.</p>

<p>Referenced by <a class="el" href="group__cobalt__core__thread.html#gae4cb747799fc0ac47e2a209c835f524d">xnthread_harden()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9321320f5f883f20a4cb411ce585f115"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnthread_resume </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume a thread. </p>
<p>Resumes the execution of a thread previously suspended by one or more calls to <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc" title="Suspend a thread. ">xnthread_suspend()</a>. This call removes a suspensive condition affecting the target thread. When all suspensive conditions are gone, the thread is left in a READY state at which point it becomes eligible anew for scheduling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the resumed thread.</td></tr>
    <tr><td class="paramname">mask</td><td>The suspension mask specifying the suspensive condition to remove from the thread's wait mask. Possible values usable by the caller are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNSUSP. This flag removes the explicit suspension condition. This condition might be additive to the XNPEND condition.</li>
<li>XNDELAY. This flag removes the counted delay wait condition.</li>
<li>XNPEND. This flag removes the resource wait condition. If a watchdog is armed, it is automatically disarmed by this call. Unlike the two previous conditions, only the current thread can set this condition for itself, i.e. no thread can force another one to pend on a resource.</li>
</ul>
<p>When the thread is eventually resumed by one or more calls to <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115" title="Resume a thread. ">xnthread_resume()</a>, the caller of <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc" title="Suspend a thread. ">xnthread_suspend()</a> in the awakened thread that suspended itself should check for the following bits in its own information mask to determine what caused its wake up:</p>
<ul>
<li>XNRMID means that the caller must assume that the pended synchronization object has been destroyed (see <a class="el" href="group__cobalt__core__synch.html#ga51febbfe4ff33ef18778fe9ecf62c43a" title="Unblock all waiters pending on a resource. ">xnsynch_flush()</a>).</li>
<li>XNTIMEO means that the delay elapsed, or the watchdog went off before the corresponding synchronization object was signaled.</li>
<li>XNBREAK means that the wait has been forcibly broken by a call to <a class="el" href="group__cobalt__core__thread.html#ga8fe02cbf0d0cebc0ca9d9522bc58e65a" title="Unblock a thread. ">xnthread_unblock()</a>.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, might-switch</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__states.html#gaa31d298d298eb696ccf840473b94912c">XNDELAY</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga9394cc02e730535e3dd8b0aabb08ea86">XNHELD</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga93d516291e0645195b35d63fbf0e0433">XNREADY</a>, and <a class="el" href="group__cobalt__core__timer.html#ga9aaa5a0dcfeb46e0e322fa7464fdb997">xntimer_stop()</a>.</p>

<p>Referenced by <a class="el" href="group__cobalt__core__synch.html#ga51febbfe4ff33ef18778fe9ecf62c43a">xnsynch_flush()</a>, <a class="el" href="group__cobalt__core__synch.html#ga54162964059c62d7a7b45ef22911662f">xnsynch_wakeup_one_sleeper()</a>, <a class="el" href="group__cobalt__core__synch.html#ga8096364cd5d717dae816c74dcc05a8ac">xnsynch_wakeup_this_sleeper()</a>, <a class="el" href="group__cobalt__core__thread.html#gabcf46b2b38ac68322f354adc408c2732">xnthread_cancel()</a>, <a class="el" href="group__cobalt__core__thread.html#ga2ff2b4720f1a104a4f26f38da3370ba4">xnthread_map()</a>, <a class="el" href="group__cobalt__core__thread.html#gabedfb90d24b08db04e49b168d290e032">xnthread_start()</a>, and <a class="el" href="group__cobalt__core__thread.html#ga8fe02cbf0d0cebc0ca9d9522bc58e65a">xnthread_unblock()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c57e5332785644f1dc0c95ad2ee5097"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_set_mode </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>clrmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>setmask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change control mode of the current thread. </p>
<p>Change the control mode of the current thread. The control mode affects several behaviours of the Cobalt core regarding this thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clrmask</td><td>Clears the corresponding bits from the control mode before setmask is applied. The scheduler lock held by the current thread can be forcibly released by passing the XNLOCK bit in this mask. In this case, the lock nesting count is also reset to zero.</td></tr>
    <tr><td class="paramname">setmask</td><td>The new thread mode. The following flags may be set in this bitmask:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNLOCK makes the current thread non-preemptible by other threads. Unless XNTRAPLB is also set for the thread, the latter may still block, dropping the lock temporarily, in which case, the lock will be reacquired automatically when the thread resumes execution.</li>
<li>XNWARN enables debugging notifications for the current thread. A SIGDEBUG (Linux-originated) signal is sent when the following atypical or abnormal behavior is detected:<ul>
<li>the current thread switches to secondary mode. Such notification comes in handy for detecting spurious relaxes.</li>
<li>CONFIG_XENO_OPT_DEBUG_MUTEX_RELAXED is enabled in the kernel configuration, and the current thread is sleeping on a Cobalt mutex currently owned by a thread running in secondary mode, which reveals a priority inversion.</li>
<li>the current thread is about to sleep while holding a Cobalt mutex, and CONFIG_XENO_OPT_DEBUG_MUTEX_SLEEP is enabled in the kernel configuration. Blocking for acquiring a mutex does not trigger such a signal though.</li>
<li>the current thread has both XNTRAPLB and XNLOCK set, and attempts to block on a Cobalt service, which would cause a lock break.</li>
</ul>
</li>
<li>XNTRAPLB disallows breaking the scheduler lock. In the default case, a thread which holds the scheduler lock is allowed to drop it temporarily for sleeping. If this mode bit is set, such thread would return immediately with XNBREAK set from <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc" title="Suspend a thread. ">xnthread_suspend()</a>. If XNWARN is set for the current thread, SIGDEBUG is sent in addition to raising the break condition.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>Setting <em>clrmask</em> and <em>setmask</em> to zero leads to a nop, in which case <a class="el" href="group__cobalt__core__thread.html#ga3c57e5332785644f1dc0c95ad2ee5097" title="Change control mode of the current thread. ">xnthread_set_mode()</a> returns the current mode. </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__info.html#gac9a2238978202123c8f045d1529c59a2">XNLBALERT</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga2defcfb1f04f077baeac9881cbdda627">XNLOCK</a>, and <a class="el" href="group__cobalt__core__sched.html#gab51b1711cd73d890278e3998c817cc3a">xnsched_run()</a>.</p>

</div>
</div>
<a class="anchor" id="gad0b5bb03ce22a7ef882729d24bfe2804"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_set_periodic </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>idate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntmode_t&#160;</td>
          <td class="paramname"><em>timeout_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a thread periodic. </p>
<p>Make a thread periodic by programming its first release point and its period in the processor time line. Subsequent calls to <a class="el" href="group__cobalt__core__thread.html#ga002449afde30d3b736ac558895ff5ab2" title="Wait for the next periodic release point. ">xnthread_wait_period()</a> will delay the thread until the next periodic release point in the processor timeline is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The core thread to make periodic. If NULL, the current thread is assumed.</td></tr>
    <tr><td class="paramname">idate</td><td>The initial (absolute) date of the first release point, expressed in nanoseconds. The affected thread will be delayed by the first call to <a class="el" href="group__cobalt__core__thread.html#ga002449afde30d3b736ac558895ff5ab2" title="Wait for the next periodic release point. ">xnthread_wait_period()</a> until this point is reached. If <em>idate</em> is equal to XN_INFINITE, the first release point is set to <em>period</em> nanoseconds after the current date. In the latter case, <em>timeout_mode</em> is not considered and can have any valid value.</td></tr>
    <tr><td class="paramname">timeout_mode</td><td>The mode of the <em>idate</em> parameter. It can either be set to XN_ABSOLUTE or XN_REALTIME with <em>idate</em> different from XN_INFINITE (see also <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b" title="Arm a timer. ">xntimer_start()</a>).</td></tr>
    <tr><td class="paramname">period</td><td>The period of the thread, expressed in nanoseconds. As a side-effect, passing XN_INFINITE attempts to stop the thread's periodic timer; in the latter case, the routine always exits succesfully, regardless of the previous state of this timer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise:</dd></dl>
<ul>
<li>-ETIMEDOUT is returned <em>idate</em> is different from XN_INFINITE and represents a date in the past.</li>
<li>-EINVAL is returned if <em>period</em> is different from XN_INFINITE but shorter than the scheduling latency value for the target system, as available from /proc/xenomai/latency. -EINVAL is also returned if <em>timeout_mode</em> is not compatible with <em>idate</em>, such as XN_RELATIVE with <em>idate</em> different from XN_INFINITE.</li>
<li>-EPERM is returned if <em>thread</em> is NULL, but the caller is not a Xenomai thread.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>, <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b">xntimer_start()</a>, and <a class="el" href="group__cobalt__core__timer.html#ga9aaa5a0dcfeb46e0e322fa7464fdb997">xntimer_stop()</a>.</p>

<p>Referenced by <a class="el" href="group__rtdm__task.html#ga44b0701b6c28fa8035711f800fdcd371">rtdm_task_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gafb78d40c8065b8569fafe7e24960742e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_set_schedparam </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnsched_class *&#160;</td>
          <td class="paramname"><em>sched_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const union xnsched_policy_param *&#160;</td>
          <td class="paramname"><em>sched_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the base scheduling parameters of a thread. </p>
<p>Changes the base scheduling policy and paramaters of a thread. If the thread is currently blocked, waiting in priority-pending mode (XNSYNCH_PRIO) for a synchronization object to be signaled, the nucleus will attempt to reorder the object's wait queue so that it reflects the new sleeper's priority, unless the XNSYNCH_DREORD flag has been set for the pended object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the affected thread. See note.</td></tr>
    <tr><td class="paramname">sched_class</td><td>The new scheduling class the thread should be assigned to.</td></tr>
    <tr><td class="paramname">sched_param</td><td>The scheduling parameters to set for the thread; <em>sched_param</em> must be valid within the context of <em>sched_class</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>It is absolutely required to use this service to change a thread priority, in order to have all the needed housekeeping chores correctly performed. i.e. Do <em>not</em> call xnsched_set_policy() directly or worse, change the thread.cprio field by hand in any case.</p>
<dl class="section return"><dt>Returns</dt><dd>0 is returned on success. Otherwise, a negative error code indicates the cause of a failure that happened in the scheduling class implementation for <em>sched_class</em>. Invalid parameters passed into <em>sched_param</em> are common causes of error.</dd></dl>
<dl class="section user"><dt>Side effects</dt><dd></dd></dl>
<ul>
<li>This service does not call the rescheduling procedure but may affect the state of the runnable queue for the previous and new scheduling classes.</li>
<li>Assigning the same scheduling class and parameters to a running or ready thread moves it to the end of the runnable queue, thus causing a manual round-robin.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unregistred</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The changes only apply to the Xenomai scheduling parameters for <em>thread</em>. There is no propagation/translation of such changes to the Linux scheduler for the task mated to the Xenomai target thread. </dd></dl>

</div>
</div>
<a class="anchor" id="ga92e19fc9deb691b7851e0f9fe21a825c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_set_slice </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>quantum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set thread time-slicing information. </p>
<p>Update the time-slicing information for a given thread. This service enables or disables round-robin scheduling for the thread, depending on the value of <em>quantum</em>. By default, times-slicing is disabled for a new thread initialized by a call to <a class="el" href="group__cobalt__core__thread.html#ga75a7e56d8c8ea2c7462db4d7a35f228e" title="Initialize a new thread. ">xnthread_init()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the affected thread.</td></tr>
    <tr><td class="paramname">quantum</td><td>The time quantum assigned to the thread expressed in nanoseconds. If <em>quantum</em> is different from XN_INFINITE, the time-slice for the thread is set to that value and its current time credit is refilled (i.e. the thread is given a full time-slice to run next). Otherwise, if <em>quantum</em> equals XN_INFINITE, time-slicing is stopped for that thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success. Otherwise, -EINVAL is returned if <em>quantum</em> is not XN_INFINITE and:</dd></dl>
<ul>
<li>the base scheduling class of the target thread does not support time-slicing,</li>
<li><em>quantum</em> is smaller than the master clock gravity for a user thread, which denotes a spurious value.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted</a> </dd></dl>

<p>References <a class="el" href="structxnsched.html#afd2e6c15e470a38b385930c613856e7b">xnsched::curr</a>, <a class="el" href="structxnsched.html#a46c9f9fdd5a35a375d6924133bde38af">xnsched::rrbtimer</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga6f451131910f816dd01fe1ec1fb50fe9">XNRRB</a>, <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b">xntimer_start()</a>, and <a class="el" href="group__cobalt__core__timer.html#ga9aaa5a0dcfeb46e0e322fa7464fdb997">xntimer_stop()</a>.</p>

</div>
</div>
<a class="anchor" id="gabedfb90d24b08db04e49b168d290e032"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_start </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct xnthread_start_attr *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a newly created thread. </p>
<p>Starts a (newly) created thread, scheduling it for the first time. This call releases the target thread from the XNDORMANT state. This service also sets the initial mode for the new thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the started thread which must have been previously initialized by a call to <a class="el" href="group__cobalt__core__thread.html#ga75a7e56d8c8ea2c7462db4d7a35f228e" title="Initialize a new thread. ">xnthread_init()</a>.</td></tr>
    <tr><td class="paramname">attr</td><td>A pointer to an attribute block describing the execution properties of the new thread. Members of this structure are defined as follows:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>mode: The initial thread mode. The following flags can be part of this bitmask, each of them affecting the nucleus behaviour regarding the started thread:<ul>
<li>XNLOCK causes the thread to lock the scheduler when it starts. The target thread will have to call the xnsched_unlock() service to unlock the scheduler. A non-preemptible thread may still block, in which case, the lock is reasserted when the thread is scheduled back in.</li>
<li>XNSUSP makes the thread start in a suspended state. In such a case, the thread will have to be explicitly resumed using the <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115" title="Resume a thread. ">xnthread_resume()</a> service for its execution to actually begin.</li>
</ul>
</li>
<li>entry: The address of the thread's body routine. In other words, it is the thread entry point.</li>
<li>cookie: A user-defined opaque cookie the nucleus will pass to the emerging thread as the sole argument of its entry point.</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if <em>thread</em> could be started ;</td></tr>
    <tr><td class="paramname">-EBUSY</td><td>if <em>thread</em> was not dormant or stopped ;</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">task-unrestricted, might-switch</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__states.html#ga5fa9672a03ebd4beaf7ab3caa5699fa6">XNDORMANT</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga2defcfb1f04f077baeac9881cbdda627">XNLOCK</a>, <a class="el" href="group__cobalt__core__sched.html#gab51b1711cd73d890278e3998c817cc3a">xnsched_run()</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga6b605ad2bb16ae2386821be8ce8d341b">XNSUSP</a>, and <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115">xnthread_resume()</a>.</p>

<p>Referenced by <a class="el" href="group__rtdm__task.html#ga44b0701b6c28fa8035711f800fdcd371">rtdm_task_init()</a>.</p>

</div>
</div>
<a class="anchor" id="gaab49f7e0bb3c3ede3d52a47ee18794bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xnthread_suspend </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xnticks_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xntmode_t&#160;</td>
          <td class="paramname"><em>timeout_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct xnsynch *&#160;</td>
          <td class="paramname"><em>wchan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend a thread. </p>
<p>Suspends the execution of a thread according to a given suspensive condition. This thread will not be eligible for scheduling until it all the pending suspensive conditions set by this service are removed by one or more calls to <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115" title="Resume a thread. ">xnthread_resume()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the suspended thread.</td></tr>
    <tr><td class="paramname">mask</td><td>The suspension mask specifying the suspensive condition to add to the thread's wait mask. Possible values usable by the caller are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>XNSUSP. This flag forcibly suspends a thread, regardless of any resource to wait for. A reverse call to <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115" title="Resume a thread. ">xnthread_resume()</a> specifying the XNSUSP bit must be issued to remove this condition, which is cumulative with other suspension bits.<em>wchan</em> should be NULL when using this suspending mode.</li>
<li>XNDELAY. This flags denotes a counted delay wait (in ticks) which duration is defined by the value of the timeout parameter.</li>
<li>XNPEND. This flag denotes a wait for a synchronization object to be signaled. The wchan argument must points to this object. A timeout value can be passed to bound the wait. This suspending mode should not be used directly by the client interface, but rather through the <a class="el" href="group__cobalt__core__synch.html#ga51cec970cb57608abe882c98bee72347" title="Sleep on an ownerless synchronization object. ">xnsynch_sleep_on()</a> call.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout which may be used to limit the time the thread pends on a resource. This value is a wait time given in nanoseconds. It can either be relative, absolute monotonic, or absolute adjustable depending on <em>timeout_mode</em>.</td></tr>
  </table>
  </dd>
</dl>
<p>Passing XN_INFINITE <b>and</b> setting <em>timeout_mode</em> to XN_RELATIVE specifies an unbounded wait. All other values are used to initialize a watchdog timer. If the current operation mode of the system timer is oneshot and <em>timeout</em> elapses before <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc" title="Suspend a thread. ">xnthread_suspend()</a> has completed, then the target thread will not be suspended, and this routine leads to a null effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_mode</td><td>The mode of the <em>timeout</em> parameter. It can either be set to XN_RELATIVE, XN_ABSOLUTE, or XN_REALTIME (see also <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b" title="Arm a timer. ">xntimer_start()</a>).</td></tr>
    <tr><td class="paramname">wchan</td><td>The address of a pended resource. This parameter is used internally by the synchronization object implementation code to specify on which object the suspended thread pends. NULL is a legitimate value when this parameter does not apply to the current suspending mode (e.g. XNSUSP).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the target thread has received a Linux-originated signal, then this service immediately exits without suspending the thread, but raises the XNBREAK condition in its information mask.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, might-switch</a> </dd></dl>

<p>References <a class="el" href="structxnsched.html#afd2e6c15e470a38b385930c613856e7b">xnsched::curr</a>, <a class="el" href="group__cobalt__core__lock.html#ga8b52de3d55575c5b15e8d494f40f8a6a">splmax</a>, <a class="el" href="group__cobalt__core__thread__info.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__cobalt__core__thread__states.html#gaa31d298d298eb696ccf840473b94912c">XNDELAY</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga9394cc02e730535e3dd8b0aabb08ea86">XNHELD</a>, <a class="el" href="group__cobalt__core__thread__info.html#gab6ee242aa7e0f98235c5099cd345984c">XNKICKED</a>, <a class="el" href="group__cobalt__core__thread__info.html#gac9a2238978202123c8f045d1529c59a2">XNLBALERT</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga93d516291e0645195b35d63fbf0e0433">XNREADY</a>, <a class="el" href="group__cobalt__core__thread__states.html#gadf5508cd88c2678ae01dfaf5570c661c">XNRELAX</a>, <a class="el" href="group__cobalt__core__thread__info.html#gab07d9dea73645dbba353dc2452c15b40">XNRMID</a>, <a class="el" href="group__cobalt__core__thread__info.html#gad28db508d297929d6a0ec30964639d65">XNROBBED</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga6b605ad2bb16ae2386821be8ce8d341b">XNSUSP</a>, <a class="el" href="group__cobalt__core__thread__info.html#gaa11d7fc754db50d3a1f1e41611d324e9">XNTIMEO</a>, <a class="el" href="group__cobalt__core__timer.html#ga5105f0fe627798b588a5f124715cb31b">xntimer_start()</a>, <a class="el" href="group__cobalt__core__thread__states.html#gad5651b09bfb391a0ac94f7d81c2e05f1">XNTRAPLB</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga4d188db22a4cc3f521934cdcc6ba7d06">XNUSER</a>, <a class="el" href="group__cobalt__core__thread__info.html#ga53e49fa49b312e5266b31d66f7465d44">XNWAKEN</a>, and <a class="el" href="group__cobalt__core__thread__states.html#ga44a2c7ec314961aacb1934636cb33482">XNWARN</a>.</p>

<p>Referenced by <a class="el" href="group__cobalt__core__synch.html#ga43fa3ecdc81f6ae157f840175c7ea091">xnsynch_acquire()</a>, <a class="el" href="group__cobalt__core__synch.html#ga51cec970cb57608abe882c98bee72347">xnsynch_sleep_on()</a>, <a class="el" href="group__cobalt__core__thread.html#ga2ff2b4720f1a104a4f26f38da3370ba4">xnthread_map()</a>, <a class="el" href="group__cobalt__core__thread.html#gaa0dad9aaac79565e12343b3b27a37c83">xnthread_relax()</a>, and <a class="el" href="group__cobalt__core__thread.html#ga002449afde30d3b736ac558895ff5ab2">xnthread_wait_period()</a>.</p>

</div>
</div>
<a class="anchor" id="gab5af31ef43f67d3124886dc5fc528753"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xnthread_test_cancel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Introduce a thread cancellation point. </p>
<p>Terminates the current thread if a cancellation request is pending for it, i.e. if <a class="el" href="group__cobalt__core__thread.html#gabcf46b2b38ac68322f354adc408c2732" title="Cancel a thread. ">xnthread_cancel()</a> was called.</p>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">mode-unrestricted</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__info.html#gac0c8d3c13b2ea3ceb9c8b474b9e52f01">XNCANCELD</a>, and <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>.</p>

<p>Referenced by <a class="el" href="group__cobalt__core__thread.html#gabcf46b2b38ac68322f354adc408c2732">xnthread_cancel()</a>, <a class="el" href="group__cobalt__core__thread.html#gae4cb747799fc0ac47e2a209c835f524d">xnthread_harden()</a>, and <a class="el" href="group__cobalt__core__thread.html#ga2ff2b4720f1a104a4f26f38da3370ba4">xnthread_map()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8fe02cbf0d0cebc0ca9d9522bc58e65a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_unblock </td>
          <td>(</td>
          <td class="paramtype">struct xnthread *&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblock a thread. </p>
<p>Breaks the thread out of any wait it is currently in. This call removes the XNDELAY and XNPEND suspensive conditions previously put by <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc" title="Suspend a thread. ">xnthread_suspend()</a> on the target thread. If all suspensive conditions are gone, the thread is left in a READY state at which point it becomes eligible anew for scheduling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>The descriptor address of the unblocked thread.</td></tr>
  </table>
  </dd>
</dl>
<p>This call neither releases the thread from the XNSUSP, XNRELAX, XNDORMANT or XNHELD suspensive conditions.</p>
<p>When the thread resumes execution, the XNBREAK bit is set in the unblocked thread's information mask. Unblocking a non-blocked thread is perfectly harmless.</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero is returned if the thread was actually unblocked from a pending wait state, 0 otherwise.</dd></dl>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">unrestricted, might-switch</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__info.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__cobalt__core__thread__states.html#gaa31d298d298eb696ccf840473b94912c">XNDELAY</a>, <a class="el" href="group__cobalt__core__thread__states.html#ga153b45ee5ddcc4da154ca8a018ac1871">XNPEND</a>, and <a class="el" href="group__cobalt__core__thread.html#ga9321320f5f883f20a4cb411ce585f115">xnthread_resume()</a>.</p>

</div>
</div>
<a class="anchor" id="ga002449afde30d3b736ac558895ff5ab2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xnthread_wait_period </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>overruns_r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the next periodic release point. </p>
<p>Make the current thread wait for the next periodic release point in the processor time line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">overruns_r</td><td>If non-NULL, <em>overruns_r</em> must be a pointer to a memory location which will be written with the count of pending overruns. This value is copied only when <a class="el" href="group__cobalt__core__thread.html#ga002449afde30d3b736ac558895ff5ab2" title="Wait for the next periodic release point. ">xnthread_wait_period()</a> returns -ETIMEDOUT or success; the memory location remains unmodified otherwise. If NULL, this count will never be copied back.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned upon success; if <em>overruns_r</em> is valid, zero is copied to the pointed memory location. Otherwise:</dd></dl>
<ul>
<li>-EWOULDBLOCK is returned if <a class="el" href="group__cobalt__core__thread.html#gad0b5bb03ce22a7ef882729d24bfe2804" title="Make a thread periodic. ">xnthread_set_periodic()</a> has not previously been called for the calling thread.</li>
<li>-EINTR is returned if <a class="el" href="group__cobalt__core__thread.html#ga8fe02cbf0d0cebc0ca9d9522bc58e65a" title="Unblock a thread. ">xnthread_unblock()</a> has been called for the waiting thread before the next periodic release point has been reached. In this case, the overrun counter is reset too.</li>
<li>-ETIMEDOUT is returned if the timer has overrun, which indicates that one or more previous release points have been missed by the calling thread. If <em>overruns_r</em> is valid, the count of pending overruns is copied to the pointed memory location.</li>
</ul>
<dl class="section user"><dt>Tags</dt><dd><a class="el" href="group__cobalt__core.html">primary-only, might-switch</a> </dd></dl>

<p>References <a class="el" href="group__cobalt__core__thread__info.html#ga6aa575e1a99b9c931d3b1feb8bc7a36f">XNBREAK</a>, <a class="el" href="group__cobalt__core__thread__states.html#gaa31d298d298eb696ccf840473b94912c">XNDELAY</a>, <a class="el" href="group__cobalt__core__thread.html#ga277e327d3802107ed35dc768cb01509c">xnthread_current()</a>, <a class="el" href="group__cobalt__core__thread.html#gaab49f7e0bb3c3ede3d52a47ee18794bc">xnthread_suspend()</a>, and <a class="el" href="group__cobalt__core__timer.html#ga43632fbc3c902df8a710c3d85ca7457c">xntimer_get_overruns()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.9.1 </li>
  </ul>
</div>
</body>
</html>
